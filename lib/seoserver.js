// Generated by CoffeeScript 1.6.2
(function() {
  var $, SeoServer, args, defaultConfig, express, logentries, memcached, querystring, seoserver, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  express = require('express');

  memcached = require('memcached');

  $ = require('jquery');

  _ = require('underscore');

  logentries = require('node-logentries');

  querystring = require('querystring');

  defaultConfig = require('./config');

  SeoServer = (function() {
    function SeoServer(config) {
      if (config == null) {
        config = {};
      }
      this.fetchFromPhantom = __bind(this.fetchFromPhantom, this);
      this.storeResponseInCache = __bind(this.storeResponseInCache, this);
      this.responseHandler = __bind(this.responseHandler, this);
      this.start = __bind(this.start, this);
      this.config = _.defaults(config, defaultConfig);
      console.log("Launching with config: ", this.config);
    }

    SeoServer.prototype.start = function() {
      var dfd,
        _this = this;

      dfd = $.Deferred();
      if (this.config.logentries.enabled) {
        this.initLogentries();
      }
      memcached = this.initMemcached();
      memcached.fail(function(error) {
        return console.log("Got memcached connection error: " + error);
      });
      memcached.done(function(connection) {
        return console.log("Connected to memcached.");
      });
      memcached.always(function() {
        _this.app = express();
        _this.app.get(/(.*)/, _this.responseHandler);
        _this.app.listen(_this.config.defaultPort);
        console.log("Express server started at port " + _this.config.defaultPort);
        return dfd.resolve();
      });
      return dfd.promise();
    };

    SeoServer.prototype.initLogentries = function() {
      this.log = logentries.logger({
        token: this.config.logentries.token
      });
      return console.log("Initialized logentries logger");
    };

    SeoServer.prototype.responseHandler = function(request, response) {
      var now,
        _this = this;

      this.timer = 0;
      now = +new Date();
      return this.fetchPage(request, response).done(function(url, headers, content) {
        _this.logResponseStats(request, headers, +(new Date) - now);
        response.status(headers.status || 500);
        if (headers.contentType) {
          response.header("Content-type", headers.contentType);
        }
        response.header("Access-Control-Allow-Origin", "*");
        response.header("Access-Control-Allow-Headers", "X-Requested-With");
        if (headers.location != null) {
          response.set('Location', headers.location);
          return response.send('');
        } else {
          return response.send(content);
        }
      });
    };

    SeoServer.prototype.fetchPage = function(request, response) {
      var dfd, fetchDfd, url,
        _this = this;

      dfd = $.Deferred();
      url = this.buildURL(request);
      if (this.memcachedClient) {
        fetchDfd = this.fetchFromMemcached(request);
      } else {
        fetchDfd = this.fetchFromPhantom(url);
      }
      fetchDfd.fail(function() {
        return dfd.reject();
      });
      fetchDfd.done(function(url, headers, content) {
        _this.storeResponseInCache(request, headers, content);
        return dfd.resolve(url, headers, content);
      });
      return dfd.promise();
    };

    SeoServer.prototype.storeResponseInCache = function(request, headers, content) {
      var key, url, _ref;

      if (!this.memcachedClient) {
        return;
      }
      if (headers.status === 301) {
        content = "301 " + headers.location;
      }
      url = this.buildURL(request);
      key = this.buildKey(url);
      if (headers.status >= 200 && (headers.status < 300 || ((_ref = headers.status) === 301 || _ref === 302))) {
        return this.memcachedClient.set(key, content, 259200, function(err) {
          if (err) {
            return console.log(err);
          }
        });
      }
    };

    SeoServer.prototype.buildURL = function(request) {
      var params;

      params = _(request.query).pick(this.config.getParamWhitelist);
      if (_(params).isEmpty()) {
        return this.config.host + request.path;
      } else {
        return "" + this.config.host + request.path + "?" + (querystring.stringify(params));
      }
    };

    SeoServer.prototype.buildKey = function(url) {
      return "" + this.config.memcached.key + ":" + url;
    };

    SeoServer.prototype.fetchFromMemcached = function(request) {
      var clearCache, dfd, key, url,
        _this = this;

      dfd = $.Deferred();
      url = this.buildURL(request);
      key = this.buildKey(url);
      clearCache = request.query.plan === 'titanium';
      this.memcachedClient.get(key, function(error, cachedContent) {
        var headers, matches, phantomRequest;

        if (error) {
          return dfd.reject("memcached error: " + error);
        }
        if (cachedContent && !clearCache) {
          headers = {};
          if (/^301/.test(cachedContent)) {
            matches = cachedContent.match(/\s(.*)$/);
            headers.status = 301;
            headers.location = matches[1];
          }
          headers.memcached = true;
          headers.status = 200;
          return dfd.resolve(url, headers, cachedContent);
        } else {
          phantomRequest = _this.fetchFromPhantom(url);
          phantomRequest.done(dfd.resolve);
          return phantomRequest.fail(dfd.fail);
        }
      });
      return dfd.promise();
    };

    SeoServer.prototype.fetchFromPhantom = function(url) {
      var content, dfd, headers, phantom, timeout,
        _this = this;

      dfd = $.Deferred();
      timeout = null;
      headers = {};
      content = '';
      phantom = require('child_process').spawn('phantomjs', [__dirname + '/phantom-server.js', url]);
      timeout = setTimeout(function() {
        return phantom.kill();
      }, 30000);
      phantom.stdout.on('data', function(data) {
        var match, responseHeaders;

        data = data.toString();
        if (headers.status === 503) {
          return;
        }
        if (match = data.match(/\n--HEADERS--\n({.*?})\n--HEADERS-END--\n/)) {
          responseHeaders = JSON.parse(match[1]);
          if (responseHeaders.status) {
            headers.status = responseHeaders.status;
          }
          if (responseHeaders.status === 301) {
            headers.location = responseHeaders.redirectURL;
          }
          headers.contentType = responseHeaders["contentType"];
          data = data.replace(/.*?--HEADERS-END--\n/g, '');
        }
        if (data.match(/^\w*error/i)) {
          headers.status = 503;
          if (_this.config.logentries.enabled) {
            return _this.logEntries({
              url: url,
              phantomError: data.toString()
            });
          } else {
            return console.log("js error: " + data.toString());
          }
        } else {
          return content += data.toString();
        }
      });
      phantom.stderr.on('data', function(data) {
        return console.log('stderr: ' + data);
      });
      phantom.on('exit', function(code) {
        clearTimeout(timeout);
        if (code) {
          console.log('Error on PhantomJS process');
          return dfd.fail(code);
        } else {
          content = _this.removeScriptTags(content);
          return dfd.resolve(url, headers, content);
        }
      });
      return dfd.promise();
    };

    SeoServer.prototype.initMemcached = function() {
      var client, dfd, server,
        _this = this;

      console.log("Launching memcached client");
      dfd = $.Deferred();
      if (!this.config.memcached.enabled) {
        return dfd.reject('memcached is disabled');
      }
      memcached.config.retries = this.config.memcached.connectRetries;
      memcached.config.maxValue = this.config.memcached.maxValue;
      server = "" + this.config.memcached.defaultHost + ":" + this.config.memcached.defaultPort;
      client = new memcached(server);
      client.on('failure', function(details) {
        var error;

        error = "Memcached connection failure on: " + details.server + "        due to: " + (details.messages.join(' '));
        return dfd.reject(error);
      });
      client.on('reconnecting', function(details) {
        return console.log("memcached: Total downtime caused by server        " + details.server + " : " + details.totalDownTime + " ms");
      });
      console.log("Trying to connect to memcached server " + server);
      client.connect(server, function(error, connection) {
        if (error) {
          return dfd.reject(error);
        } else {
          _this.memcachedClient = client;
          return dfd.resolve();
        }
      });
      return dfd.promise();
    };

    SeoServer.prototype.logResponseStats = function(request, headers, time) {
      var crawler, fullURL, status, url;

      fullURL = this.buildURL(request);
      url = fullURL.replace(new RegExp("" + this.config.host), '');
      status = headers.memcached ? "MEMCACHED" : headers.status ? headers.status : "KILLED";
      crawler = /RedSnapper/.test(request.headers['user-agent']) ? 'Crawler' : 'GoogleBot';
      console.log(crawler, status, "Time:", time + "ms", "|", (time / 1000).toFixed(2) + "s", url);
      if (status >= 400 || status === "KILLED") {
        return this.logEntries({
          status: status,
          time: time,
          url: fullURL
        });
      }
    };

    SeoServer.prototype.logEntries = function(payload) {
      if (!this.config.logentries.enabled) {
        return;
      }
      return this.log.err(payload);
    };

    SeoServer.prototype.removeScriptTags = function(content) {
      return content.replace(/<script[\s\S]*?<\/script>/gi, '');
    };

    return SeoServer;

  })();

  module.exports = SeoServer;

  args = process.argv.splice(2);

  if ((args != null ? args[0] : void 0) === 'start') {
    seoserver = new SeoServer();
    seoserver.start();
  }

}).call(this);
